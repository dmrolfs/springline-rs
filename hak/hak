#!/usr/bin/python3.9
"""
This is a HERE Account kubernetes credential plugin.
It reads a credentials.properties file and generates an ExecCredential response
which kubectl can consume and use for authentication.

See:
https://kubernetes.io/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins

Token-generation code taken from icli:
https://gerrit.it.here.com/gitweb?p=olp/dp/icli.git;a=blob;f=icli/here_account.py;h=c9f10d72132a9716fa10059777e04d5049381fe6;hb=9ffd73412a98fb62897e9d33edcd4f237540f705
"""

import base64
import hashlib
import hmac
import json
import logging
import os
import time
import argparse
import secrets
from urllib.parse import quote, urlencode, urljoin

import requests


LOG = logging.getLogger(__name__)


def get_oidc(creds_buffer):
    creds = {}
    for line in creds_buffer.read().splitlines():
        if "=" in line:
            key, value = line.split("=", 1)
            creds[key.strip()] = value.strip()

    url = creds["here.token.endpoint.url"]
    access_key_id = creds["here.access.key.id"]
    access_key_secret = creds["here.access.key.secret"]
    client_group = creds.get("here.client.group")

    return get_oidc_token(url, access_key_id, access_key_secret, client_group)


def get_oidc_token(url, access_key_id, access_key_secret, client_group):
    logging.debug("Getting OIDC for: %s", client_group)

    sig = SignatureCalculator(access_key_id, access_key_secret)
    ha_client = HAClient(url, sig)

    scope = "openid {}".format(client_group) if client_group else "openid"

    logging.debug("Requesting oidc with scope %s", scope)
    oidc_creds = ha_client.get_oidc_credentials(scope)
    return oidc_creds['id_token']


class SignatureCalculator(object):
    def __init__(self, consumer_key, consumer_secret):
        self._key = consumer_key
        self._secret = consumer_secret
        LOG.debug("Access key: %s", self._key)
        LOG.debug("Secret key: %s", self._secret)

    def calculate_authorization(
        self,
        method,
        base_url,
        oauth_timestamp=None,
        nonce=None,
        signature_method="HMAC-SHA256",
        formparams=None,
        queryparams=None,
        oauth_version="1.0",
    ):
        if not nonce:
            nonce = secrets.token_hex(16)  # this line was broken before, seems unreachable code
        if not oauth_timestamp:
            oauth_timestamp = time.time()
        sig = self.calculate_signature(
            method,
            base_url,
            oauth_timestamp,
            nonce,
            signature_method,
            formparams,
            queryparams,
            oauth_version
        )
        return (
            'OAuth '
            'oauth_consumer_key="{}",'
            'oauth_signature_method="{}",'
            'oauth_timestamp="{}",'
            'oauth_nonce="{}",'
            'oauth_version="{}",'
            'oauth_signature="{}"'
        ).format(
            quote(self._key),
            quote(signature_method),
            quote(str(oauth_timestamp)),
            quote(nonce),
            quote(oauth_version),
            quote(sig),
        )

    def calculate_signature(
        self,
        method,
        base_url,
        oauth_timestamp,
        nonce,
        signature_method="HMAC-SHA256",
        formparams=None,
        queryparams=None,
        oauth_version="1.0"
    ):
        base_string = self.calculate_basestring(
            method, base_url, oauth_timestamp, nonce,
            signature_method, formparams, queryparams, oauth_version)
        if signature_method == "HMAC-SHA256":
            return self.calculate_hmac_sha256_signature(base_string)
        else:
            raise NotImplementedError(
                "{} signatures are not yet implemented".format(
                    signature_method))

    def calculate_basestring(
        self,
        method,
        base_url,
        oauth_timestamp,
        nonce,
        signature_method="HMAC-SHA256",
        formparams=None,
        queryparams=None,
        oauth_version="1.0"
    ):
        params = [
            ("oauth_consumer_key", self._key),
            ("oauth_nonce", nonce),
            ("oauth_signature_method", signature_method),
            ("oauth_timestamp", oauth_timestamp),
            ("oauth_version", oauth_version)
        ]
        if formparams:
            for key, value in formparams.items():
                params.append((key, value,))
        if queryparams:
            for key, value in queryparams.items():
                params.append((key, value,))

        base_string = "{}&{}&{}".format(
            method.upper(),
            quote(base_url, ""),
            quote(urlencode(sorted(params))),  # CHECK THIS
        )
        LOG.debug("base_string: %s", base_string)
        return base_string

    def calculate_hmac_sha256_signature(self, base_string):
        dig = hmac.new(
            key=(self._secret+'&').encode('utf-8'),
            msg=base_string.encode('utf-8'),
            digestmod=hashlib.sha256
        )
        b64digest = base64.b64encode(dig.digest()).strip()
        LOG.debug("Calculating signature of %r with %r", base_string, self._secret)
        LOG.debug("Calculated signature: %s", b64digest)
        return b64digest


class HAClient(object):
    def __init__(self, base_url, signature_calculator):
        self._url = base_url
        self._sig = signature_calculator

    def _dry_run(self, method, url, headers, data=None):
        print("{} {}".format(method, url))
        for k, v in sorted(headers.items()):
            print("%s: %s" % (k, v))
        if data:
            print()
            print(json.dumps(data, indent=2))

    def get_server_timestamp(self):
        url = urljoin(self._url, "/timestamp")
        headers = {
            "Content-Type": "application/json"
        }
        resp = self._GET(url, headers=headers)
        return resp.json()

    def get_oidc_credentials(self, scope, dry_run=False):
        url = urljoin(self._url, "/oauth2/token")
        data = {
            "grantType": "client_credentials",
            "expiresIn": 86400,
            "scope": scope
        }

        server_timestamp = self.get_server_timestamp()
        client_timestamp = int(time.time())
        oauth_timestamp = server_timestamp.get('timestamp', client_timestamp)

        auth = self._sig.calculate_authorization(
            method="POST",
            base_url=url,
            oauth_timestamp=str(oauth_timestamp),
            nonce=secrets.token_hex(16),
            signature_method="HMAC-SHA256",
            formparams=None,
            queryparams=None,
        )
        headers={
            "Content-Type": "application/json",
            "Authorization": auth,
        }

        if dry_run:
            self._dry_run("POST", url, headers, data)
            return

        resp = self._POST(url, data, headers=headers)
        return resp.json()

    def _GET(self, url, headers={}):
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        return response

    def _POST(self, url, data, headers={}):
        response = requests.post(url, data=json.dumps(data), headers=headers)
        response.raise_for_status()
        return response


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Generate a k8s token from HERE account credentials'
    )
    default_creds = os.getenv(
        'HA_CREDENTIALS',
        os.path.join(os.path.expanduser('~'), '.here', 'credentials.properties')
    )
    parser.add_argument('--creds', nargs='?', type=argparse.FileType('r'),
                        default=default_creds,
                        help='HERE account credentials.properties file')

    args = parser.parse_args()
    token = get_oidc(args.creds)
    print(json.dumps({
        "apiVersion": "client.authentication.k8s.io/v1beta1",
        "kind": "ExecCredential",
        "status": {
            "token": token,
        }
    }))
